/*
 * ManRiX Microkernel
 * Copyright (C) 2004, 2005
 * 	Manish Regmi (regmi dot manish at gmail dot com) and
 * 	Rajesh R.C   (rajee5283@hotmail.com)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */
/*
 * File:- signal.h
 * 	Macros and structures for POSIX style Signal Implementation.
 *
 */

#ifndef __SIGNAL_H
#define __SIGNAL_H

#ifndef __SYS_TYPES_H
#include <sys/types.h>
#endif

typedef void (*sa_handler)(int);

#define SIG_DFL		(0)
#define SIG_IGN		(1)
#define SIG_ERR		(-1)

#define	SIGEV_NONE	0
#define SIGEV_SIGNAL	1
#define SIGEV_THREAD	2

#define SIGABRT		1
#define SIGALRM		2
#define SIGBUS		3
#define SIGCHLD		4
#define SIGCONT		5
#define SIGFPE		6
#define SIGHUP		7
#define SIGILL		8
#define SIGINT		9
#define SIGKILL		10
#define SIGPIPE		11
#define SIGPROF		12
#define SIGQUIT		13
#define SIGSEGV		14
#define SIGSTOP		15
#define SIGSYS		16
#define SIGTERM		17
#define SIGTRAP		18
#define SIGTSTP		19
#define SIGTTIN		20
#define SIGTTOU		21
#define SIGURG		22
#define SIGUSR1		23
#define SIGUSR2		24
#define SIGXCPU		25
#define SIGXFSZ		26

/* realtime signals. */
#define SIGRTMIN	27
#define SIGRTMAX	31

/* Sigaction flags */
#define SA_NOCLDSTOP	1
#define SA_RESTART		2
#define SA_ONSTACK		4
#define SA_RESETHAND	8
#define SA_SIGINFO		0x10
#define SA_NOCLDWAIT	0x20
#define SA_NODEFER		0x40
//#define SA_UNRELIABLE	8	/* for signal call */

/* Sigprocmask How field */
#define SIG_BLOCK	1
#define SIG_UNBLOCK	2
#define SIG_SETMASK	4

/* Stack Flags */
#define SS_ONSTACK	1
#define SS_DISABLE	2

#define MINSIGSTKSZ	512
#define SIGSTKSZ	1024

/* signal codes */

/* SIGILL */
#define ILL_ILLOPC	1	/* Illegal opcode. */
#define ILL_ILLOPN	2	/* Illegal operand. */
#define ILL_ILLADR	3	/* Illegal addressing mode. */
#define ILL_ILLTRP	4	/* Illegal trap. */
#define ILL_PRVOPC	5	/* Privileged opcode. */
#define ILL_PRVREG	6	/* Privileged register. */
#define ILL_COPROC	7	/* Coprocessor error.	*/
#define ILL_BADSTK	8	/* Internal stack error.*/

/* SIGFPE */
#define FPE_INTDIV	9	/* Integer divide by zero.*/
#define FPE_INTOVF	10	/* Integer overflow. */
#define FPE_FLTDIV	11	/* Floating-point divide by zero. */
#define FPE_FLTOVF	12	/* Floating-point overflow. */
#define FPE_FLTUND	13	/* Floating-point underflow. */
#define FPE_FLTRES	14	/* Floating-point inexact result. */
#define FPE_FLTINV	15	/* Invalid floating-point operation. */
#define FPE_FLTSUB	16	/* Subscript out of range. */

/* SIGSEGV */
#define SEGV_MAPERR	17	/* Address not mapped to object. */
#define SEGV_ACCERR	18	/* Invalid permissions for mapped object. */

/* SIGBUS */
#define BUS_ADRALN	19	/* Invalid address alignment. */
#define BUS_ADRERR	20	/* Nonexistent physical address. */
#define BUS_OBJERR	21	/* Object-specific hardware error. */

/* SIGTRAP */
#define TRAP_BRKPT	22	/* Process breakpoint. */
#define TRAP_TRACE	23	/* Process trace trap. */

/* SIGCHLD */
#define CLD_EXITED	24	/* Child has exited. */
#define CLD_KILLED	25	/* Child has terminated abnormally and did not create a core file. */
#define CLD_DUMPED	26	/* Child has terminated abnormally and created a core file.	*/
#define CLD_TRAPPED	27	/* Traced child has trapped. */
#define CLD_STOPPED	28	/* Child has stopped. */
#define CLD_CONTINUED	29	/* Stopped child has continued. */

/* SIGPOLL */
#define POLL_IN		30	/* Data input available. */
#define POLL_OUT	31	/* Output buffers available. */
#define POLL_MSG	32	/* Input message available. */
#define POLL_ERR	33	/* I/O error. */
#define POLL_PRI	34	/* High priority input available. */
#define POLL_HUP	35	/* Device disconnected. */

/* Any */
#define SI_USER		36	/* Signal sent by kill(). */
#define SI_QUEUE	37	/* Signal sent by the sigqueue().*/
#define SI_TIMER	38	/* Signal generated by expiration of a timer set by timer_settime(). */
#define SI_ASYNCIO	39	/* Signal generated by completion of an asynchronous I/O request. */
#define SI_MESGQ	40	/* Signal generated by arrival of a message on an empty message queue. */

typedef int sigset_t;
typedef volatile int sig_atomic_t;

union sigval{
	int sigval_int;
	void *sigval_ptr;
};

struct stack{
	void	*ss_sp;
	size_t	ss_size;
	int	ss_flags;
};

typedef struct stack stack_t;

struct sigstack{
	int      ss_onstack;  /* Non-zero when signal stack is in use.  */
	void     *ss_sp;      /* Signal stack pointer. */
};

struct sigevent{
	int sigev_notify;
	int sigev_signo;
	union sigval handler;
#define sigev_value handler.sigval_int
};

struct siginfo {
	int si_signo;
	int si_code;
	int si_errno;
	pid_t si_pid;
	void *si_addr;
	int si_status;
	//long si_band;
	union sigval si_value;
};

typedef struct siginfo siginfo_t;

/* Action to be taken on signal reception */
struct sigaction{
	sigset_t	sa_mask;
	int 		sa_flags;
	union handler{
		void (*sa_handler)(int);
		void (*sa_sigaction)(int, siginfo_t, void*);
	} action;
#define sa_handler action.sa_handler
#define sa_sigaction action.sa_sigaction
};


#endif /* __SIGNAL_H */

